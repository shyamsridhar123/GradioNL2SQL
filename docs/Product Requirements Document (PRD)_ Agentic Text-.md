<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

## Product Requirements Document (PRD): Agentic Text-to-SQL and Stored Procedure Application Using Smolagents, Azure SQL, and Gradio


---

### **1. Overview**

This application enables users to input natural language queries and receive answers generated by an AI agent that translates text to SQL or invokes stored procedures on an Azure SQL Server database. The system uses smolagents for agent orchestration, and Gradio as the user-facing interface. The focus is on reliability, security, and the ability to handle complex queries and stored procedure calls without caching layers like Redis.

---

### **2. Goals and Objectives**

- Enable users to query and analyze data from Azure SQL Server using natural language.
- Support both dynamic SQL generation and execution of pre-approved stored procedures.
- Provide a transparent, auditable, and secure environment for query execution.
- Deliver a user-friendly web interface leveraging Gradio.
- Ensure robust error handling, logging, and LLM-driven correction for failed queries[^1][^4][^5].

---

### **3. Functional Requirements**

#### **3.1 User Interface (Gradio)**

- Text input box for user queries.
- Display area for results, errors, and agent reasoning steps (optional: chat-style history).
- Option to select between “Query” (text-to-SQL) and “Stored Procedure” modes.


#### **3.2 Agent System (Smolagents)**

- **Schema Analyst Tool:** Extracts relevant schema details from Azure SQL (tables, columns, relationships).
- **SQL Generation Tool:** Converts user intent and schema context into safe, parameterized T-SQL.
- **Stored Procedure Tool:** Executes only whitelisted stored procedures with validated parameters.
- **Error Correction:** On failure, agent inspects error messages, adjusts the query, and retries[^1][^4][^5].
- **Logging:** All tool calls and errors are logged for transparency and debugging[^5].


#### **3.3 Database Layer**

- Secure connection to Azure SQL Server using SQLAlchemy and pyodbc.
- Enforced read-only access for dynamic SQL; restricted write access only for approved procedures.
- Parameterized queries to prevent SQL injection.


#### **3.4 Security and Compliance**

- Strict whitelisting of stored procedures.
- No direct dynamic SQL writes (INSERT/UPDATE/DELETE) unless explicitly allowed.
- Audit logging of all queries and procedure calls.
- No sensitive data cached or persisted outside Azure SQL.

---

### **4. Non-Functional Requirements**

- **Performance:** Sub-second response for most queries; batch processing for heavy workloads.
- **Reliability:** Robust error handling, automatic retries, and clear user feedback on failures.
- **Scalability:** Support for multiple concurrent users via Gradio.
- **Extensibility:** Easy to add new tools, stored procedures, or database schemas[^3][^5][^6].
- **Security:** Use Azure Managed Identity or secure credentials; enforce least-privilege SQL roles.

---

### **5. System Architecture**

**Components:**

- Gradio Web UI
- Smolagents orchestrator (Python backend)
- Azure SQL Server
- Logging/Audit subsystem

**Flow:**

1. User submits a query via Gradio.
2. Smolagent analyzes intent, fetches schema (if needed), and generates SQL or stored procedure call.
3. SQL/procedure is executed on Azure SQL Server.
4. Results (or errors) are returned and displayed in Gradio.
5. All actions are logged for audit and debugging.

---

### **6. Implementation Best Practices**

- Use detailed docstrings and argument validation in all tools[^5].
- Log all tool calls, inputs, outputs, and errors for LLM self-correction[^5].
- Pass schema and error context explicitly to the agent to improve accuracy[^5].
- Use Gradio’s `ChatInterface` or `Interface` for flexible UI[^3].
- Modularize tools for easy maintenance and extension[^3][^5][^6].

---

### **7. Example User Stories**

- _As a business analyst, I want to ask “Show me the top 10 customers by revenue last quarter” and get results instantly._
- _As a data engineer, I want to execute the stored procedure `usp_GenerateMonthlyReport` with custom parameters._
- _As an admin, I want to see logs of all queries and errors for compliance review._

---

### **8. Out of Scope**

- No Redis or external caching.
- No direct schema modifications or DDL statements via the agent.
- No support for non-Azure databases.

---

### **9. References**

- Smolagents documentation and best practices[^1][^3][^5][^6].
- Example agent workflows for text-to-SQL and error correction[^1][^4][^5].
- Gradio integration patterns for agent-based applications[^3].

---

### **10. Success Metrics**

- >95% accuracy in translating natural language to correct SQL/stored procedure calls.
- <2 seconds average response time for standard queries.
- 100% of queries and errors logged and auditable.

---

### **11. LLM Model Strategy, Pros & Cons, and Mitigation**

#### **LLM Model Strategy**
- **Primary LLM:** Use GPT-4o-mini for most agent tasks (schema analysis, intent parsing, validation, explanation) to optimize for cost and speed.
- **Secondary LLM:** Use GPT-4-turbo (or GPT-4.1) for complex query planning and SQL generation, especially for multi-step, multi-level, or analytical queries.
- **Routing:** Implement a rule-based router to select the model based on query complexity, agent type, and user override.
- **Azure OpenAI Integration:** Deploy both models in Azure for security, compliance, and low-latency access to Azure SQL.

#### **Pros**
- **Cost Efficiency:** Most queries use GPT-4o-mini, reducing LLM costs by 70–80% compared to using GPT-4 for all tasks.
- **Performance:** GPT-4o-mini is fast and supports high concurrency; smol agents can run in parallel.
- **Modularity:** Each agent is focused, making the system easy to maintain, extend, and debug.
- **Security:** Azure OpenAI and Azure SQL provide enterprise-grade security, with managed identity and VNet integration.
- **User Experience:** Gradio UI is modern and interactive, with fast responses for most queries.

#### **Cons & Mitigations**
- **Model Switching Complexity:**
  - *Con:* Routing between models adds orchestration complexity.
  - *Mitigation:* Use a clear, rule-based router and log model usage for debugging and cost tracking.
- **Quality Gaps for Complex Queries:**
  - *Con:* GPT-4o-mini may underperform on very complex SQL or nuanced logic.
  - *Mitigation:* Always validate and escalate to GPT-4-turbo as needed; allow user override for critical queries.
- **Latency for Complex Queries:**
  - *Con:* GPT-4-turbo is slower for complex queries.
  - *Mitigation:* Use async processing, show progress indicators, and cache results of expensive queries.
- **Token Limitations:**
  - *Con:* Large schemas or long query chains may hit context window limits.
  - *Mitigation:* Prune schema/context to only relevant tables/columns; use schema summarization agents.
- **Error Propagation:**
  - *Con:* If one agent fails, the pipeline may break.
  - *Mitigation:* Add robust error handling, fallback logic, and allow agents to retry or request clarification from the user.
- **Security Risks (SQL Injection, Data Exposure):**
  - *Con:* Generated SQL could be unsafe if not validated.
  - *Mitigation:* Always validate and parameterize SQL before execution; restrict agent permissions and mask sensitive data in results.
- **Cost Overruns:**
  - *Con:* Unexpected usage spikes could increase costs.
  - *Mitigation:* Set usage quotas and alerts; monitor token usage and optimize prompts.
- **Vendor Lock-in:**
  - *Con:* Heavy reliance on Azure OpenAI and Azure SQL.
  - *Mitigation:* Abstract LLM and database layers for future portability; document all dependencies and design for modularity.

#### **Summary Table**

| Area                | Pro/Con         | Mitigation/Comment                        |
|---------------------|-----------------|-------------------------------------------|
| Cost                | Pro             | Use mini for most, turbo for complex      |
| Performance         | Pro             | Parallel smol agents, async UI            |
| Quality             | Con             | Validate/escalate to turbo as needed      |
| Security            | Con             | Validate/parameterize SQL, RBAC           |
| Complexity          | Con             | Rule-based router, logging, error handling|
| Scalability         | Pro             | Fast models, modular agents               |
| Vendor Lock-in      | Con             | Abstract LLM/DB, document dependencies    |

---

This section incorporates the LLM model strategy, pros/cons, and mitigation recommendations into the overall design documentation for this solution.

---

This PRD provides a clear, actionable blueprint for building a robust, agentic text-to-SQL and stored procedure interface using smolagents, Azure SQL, and Gradio.

<div style="text-align: center">⁂</div>

[^1]: https://smolagents.org/docs/text-to-sql-example/

[^2]: https://github.com/AgentOps-AI/agentops/blob/main/examples/smolagents_examples/text_to_sql.ipynb

[^3]: https://huggingface.co/docs/smolagents/index

[^4]: https://colab.research.google.com/github/huggingface/cookbook/blob/main/notebooks/en/agent_text_to_sql.ipynb

[^5]: https://smolagents.org/docs/building-good-smolagents/

[^6]: https://blog.cubed.run/smolagents-from-huggingface-a-step-by-step-guide-to-create-ai-agents-with-examples-ed9f35691b88

[^7]: https://sourceforge.net/software/compare/MetaGPT-vs-Smolagents/

