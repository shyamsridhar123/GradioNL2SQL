"""
TRULY INTELLIGENT Multi-Agent Text2SQL System
Uses LLM-powered orchestration to make smart decisions about query processing
"""

from smolagents import CodeAgent
import sys
import os
import json
from typing import Dict, Any, List

# Add src directory to path to access tools and database modules
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Import smolagents tools (not LLM-powered ones)
from tools.schema_analyst_tool import SchemaAnalystTool
from tools.sql_generation_tool import SQLGenerationTool
from tools.stored_procedure_tool import StoredProcedureTool
from tools.error_correction_tool import ErrorCorrectionTool

# Import database modules
from database.connection import DatabaseConnection
from database.config import DatabaseConfig
from utils.logging_config import get_logger

logger = get_logger("text2sql.smolagent")

class Text2SQLAgent:
    """
    Main Smolagent for Text2SQL application with all tools
    """
    def __init__(self):
        logger.info("Initializing Text2SQL Agent...")
        
        # Initialize tools
        logger.debug("Initializing schema analyst tool...")
        self.schema_analyst = SchemaAnalystTool()
        
        logger.debug("Initializing SQL generator tool...")
        self.sql_generator = SQLGenerationTool()
        
        logger.debug("Initializing stored procedure executor...")
        self.stored_proc_executor = StoredProcedureTool()
        
        logger.debug("Initializing error corrector...")
        self.error_corrector = ErrorCorrectionTool()
        
        # Initialize database connection for query execution
        logger.debug("Setting up database connection...")
        self.config = DatabaseConfig.from_env(use_managed_identity=False)
        self.db_connection = DatabaseConnection(self.config)
          # Create the CodeAgent with tools
        logger.debug("Creating CodeAgent with tools...")
        self.agent = CodeAgent(
            tools=[
                self.schema_analyst,
                self.sql_generator,
                self.stored_proc_executor,
                self.error_corrector
            ],
            model="gpt-4o-mini"  # Default model, can be overridden
        )
        
        logger.info("Text2SQL Agent initialized successfully")
    
    def process_query_mode_smolagents(self, user_query: str) -> Dict[str, Any]:
        """
        Process natural language query using TRUE SMOLAGENTS approach
        Let the CodeAgent decide which tools to use and how to use them
        """
        logger.info(f"🤖 Processing query with Smolagents CodeAgent: {user_query[:100]}...")
        
        try:
            # Let the CodeAgent decide what to do!
            prompt = f"""
            You are a Text2SQL expert. The user has asked: "{user_query}"
            
            You have access to these tools:
            - SchemaAnalystTool: Analyze database schema for relevant tables
            - SQLGenerationTool: Generate SQL queries from natural language
            - StoredProcedureTool: Execute stored procedures
            - ErrorCorrectionTool: Fix SQL errors if they occur
            
            Please:
            1. First analyze the schema to understand relevant tables
            2. Generate the appropriate SQL query
            3. If there are any errors, use the error correction tool
            4. Return the final working SQL and results
            
            Be thorough and use the tools intelligently.
            """
            
            # Let smolagents CodeAgent handle everything!
            result = self.agent.run(prompt)
            
            # Parse the CodeAgent result and format for our app
            return {
                "success": True,
                "sql": "-- Generated by Smolagents CodeAgent --\n" + str(result),
                "results": [{"Smolagents_Result": str(result)[:500] + "..." if len(str(result)) > 500 else str(result)}],
                "schema_used": "Determined automatically by CodeAgent",
                "log": f"✨ Smolagents CodeAgent completed successfully. Result length: {len(str(result))} characters",
                "approach": "smolagents_codeagent",
                "agent_reasoning": "CodeAgent automatically selected and chained appropriate tools"
            }
            
        except Exception as e:
            logger.error(f"❌ Smolagents CodeAgent failed: {e}")
            return {
                "success": False,
                "sql": "",
                "results": [],
                "schema_used": "",
                "log": f"Smolagents CodeAgent failed: {str(e)}",
                "approach": "smolagents_codeagent_failed"
            }

    def process_query_mode(self, user_query: str) -> Dict[str, Any]:
        """
        Process natural language query and generate SQL
        """
        logger.info(f"Processing query mode for: {user_query[:100]}...")
        
        try:
            # Step 1: Analyze schema for relevant tables
            logger.debug("Step 1: Analyzing schema for relevant tables...")
            schema_info = self.schema_analyst.forward(user_query)
            logger.debug(f"Schema analysis completed. Info length: {len(schema_info)}")
            
            # Step 2: Generate SQL query
            logger.debug("Step 2: Generating SQL query...")
            sql_query = self.sql_generator.forward(user_query, schema_info)
            logger.debug(f"SQL generated: {sql_query[:100]}...")
            
            # Step 3: Execute query and handle errors
            logger.debug("Step 3: Executing query...")
            try:
                results = self.db_connection.execute_query(sql_query)
                logger.info(f"Query executed successfully. {len(results)} rows returned.")
                
                return {
                    "success": True,
                    "sql": sql_query,
                    "results": results,
                    "schema_used": schema_info,
                    "log": f"Query executed successfully. {len(results)} rows returned."
                }
                
            except Exception as db_error:
                logger.warning(f"Query execution failed: {str(db_error)}")
                logger.debug("Step 4: Attempting error correction...")
                
                # Step 4: If error, try to correct it
                corrected_sql = self.error_corrector.forward(
                    sql_query, 
                    str(db_error), 
                    schema_info
                )
                
                # Try executing corrected query
                try:
                    results = self.db_connection.execute_query(corrected_sql)
                    
                    return {
                        "success": True,
                        "sql": corrected_sql,
                        "results": results,
                        "schema_used": schema_info,
                        "log": f"Original query failed. Corrected and executed successfully. {len(results)} rows returned.",
                        "original_sql": sql_query,
                        "error_corrected": str(db_error)
                    }
                    
                except Exception as retry_error:
                    return {
                        "success": False,
                        "sql": corrected_sql,
                        "results": [],
                        "schema_used": schema_info,
                        "log": f"Both original and corrected queries failed.",
                        "original_sql": sql_query,
                        "original_error": str(db_error),
                        "retry_error": str(retry_error)
                    }
                    
        except Exception as e:
            return {
                "success": False,
                "sql": "",
                "results": [],
                "schema_used": "",
                "log": f"Error in query processing: {str(e)}"
            }
    
    def process_stored_procedure_mode(self, procedure_call: str) -> Dict[str, Any]:
        """
        Process stored procedure execution request
        """
        try:
            # Parse procedure name and parameters from user input
            # Simple parsing - can be enhanced
            parts = procedure_call.strip().split()
            if len(parts) == 0:
                return {
                    "success": False,
                    "sql": "",
                    "results": [],
                    "log": "No procedure name provided"
                }
            
            procedure_name = parts[0]
            
            # For now, assume no parameters - can be enhanced to parse JSON
            parameters = "{}"
            
            # Execute stored procedure
            result_text = self.stored_proc_executor.forward(procedure_name, parameters)
            
            return {
                "success": True,
                "sql": f"EXEC {procedure_name}",
                "results": [{"output": result_text}],
                "log": f"Stored procedure executed: {procedure_name}"
            }
            
        except Exception as e:
            return {
                "success": False,
                "sql": "",
                "results": [],
                "log": f"Error executing stored procedure: {str(e)}"
            }
    
    def run(self, user_input: str, mode: str) -> tuple:
        """
        Main interface for Gradio - returns (sql, results, log)
        """
        if mode == "Query":
            result = self.process_query_mode(user_input)
        else:  # Stored Procedure mode
            result = self.process_stored_procedure_mode(user_input)
        
        # Format for Gradio UI
        sql_output = result.get("sql", "")
        
        # Format results for display
        results_data = result.get("results", [])
        if results_data and isinstance(results_data, list) and len(results_data) > 0:
            # Convert to list of dicts for Gradio DataFrame
            if isinstance(results_data[0], dict):
                results_display = results_data
            else:
                results_display = [{"Result": str(row)} for row in results_data]
        else:
            results_display = [{"Message": "No results"}]
        
        log_output = result.get("log", "No log available")
        
        return sql_output, results_display, log_output
